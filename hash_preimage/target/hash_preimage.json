{"noir_version":"0.33.0+325dac54efb6f99201de9fdeb0a507d45189607d","hash":5838210652156115125,"abi":{"parameters":[{"name":"hash","type":{"kind":"field"},"visibility":"public"},{"name":"hash_preimage","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"29":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\nuse crate::hash::poseidon::PoseidonConfig;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(\n        consts::x5_2_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(\n        consts::x5_3_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(\n        consts::x5_4_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(\n        consts::x5_5_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(\n        consts::x5_6_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(\n        consts::x5_7_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(\n        consts::x5_8_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(\n        consts::x5_9_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(\n        consts::x5_10_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(\n        consts::x5_11_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(\n        consts::x5_12_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(\n        consts::x5_13_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(\n        consts::x5_14_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(\n        consts::x5_15_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(\n        consts::x5_16_config(),\n        state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(\n        consts::x5_17_config(),\n        state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"30":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\nmod perm;\nmod consts;\n\nuse crate::hash::poseidon::{PoseidonConfig, absorb};\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of §3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i+1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"31":{"source":"mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::field::modulus_num_bits;\nuse crate::hash::Hasher;\nuse crate::default::Default;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\nstruct PoseidonConfig<let T: u32, let N: u32, let X: u32> { \n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n     // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X]\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T]\n) -> [Field; T] {\n    let PoseidonConfig {t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } = pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf/2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf/2+1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O] // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i+1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\n// Check security of sponge instantiation\nfn check_security(rate: Field, width: Field, security: Field) -> bool {\n    let n = modulus_num_bits();\n\n    ((n - 1) as Field * (width - rate) / 2) as u8 > security as u8\n}\n\nstruct PoseidonHasher{\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        } \n        if len == 2 {\n            result = bn254::hash_2([self._state[0],self._state[1]]);\n        } \n        if len == 3 {\n            result = bn254::hash_3([self._state[0],self._state[1],self._state[2]]);\n        } \n        if len == 4 {\n            result = bn254::hash_4([self._state[0],self._state[1],self._state[2],self._state[3]]);\n        } \n        if len == 5 {\n            result = bn254::hash_5([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4]]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5]]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6]]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7]]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8]]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9]]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10]]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11]]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12]]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13]]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([self._state[0],self._state[1],self._state[2],self._state[3],self._state[4], self._state[5], self._state[6], self._state[7], self._state[8], self._state[9], self._state[10], self._state[11], self._state[12], self._state[13], self._state[14]]);\n        }\n        \n        result\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher{\n    fn default() -> Self{\n        PoseidonHasher{\n            _state: &[],\n        }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a, 0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29, 0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c\n            ];\n            assert_eq(expected, poseidon::bn254::perm::x5_3(state), \"Failed to reproduce output for [0, 1, 2]\");\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465, 0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d, 0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907, 0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e, 0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7\n            ];\n            assert_eq(\n                expected, poseidon::bn254::perm::x5_5(state), \"Failed to reproduce output for [0, 1, 2, 3, 4]\"\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"57":{"source":"use dep::std::hash::poseidon;\n\nfn main(hash: pub Field, hash_preimage: Field) {\n    let internal_hash = poseidon::bn254::hash_1([hash_preimage]);\n\n    assert(internal_hash == hash);\n}\n\n#[test]\nfn test_main() {\n    let hash_preimage = 0;\n    let hash = poseidon::bn254::hash_1([hash_preimage]);\n\n    main(hash, hash_preimage);\n}\n","path":"/Users/riemann/Desktop/zkvideo/zk-imt/hash_preimage/src/main.nr"}},"names":["main"]}